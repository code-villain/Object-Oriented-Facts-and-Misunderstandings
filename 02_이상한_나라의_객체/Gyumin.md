# 객체지향의 사실과 오해

## **02** 이상한 나라의 객체

- 객체란? **상태(state), 행동(behavior), 식별자(identity)**를 지닌 실체

- 어떤 행동의 결과는 '상태'에 의존하며, 상태는 해당 객체가 과거에 수행했던 행동들로부터의 최종 결과물이다. 상태를 통해 행동의 결과를 예측할 수 있다.

- 객체의 상태는 '단순한 값'과 '객체(를 가리키는 링크)'의 조합이며, 모두를 통틀어 객체의 '프로퍼티(property)'라고 한다.
  - 링크를 갖고있다는 것은 해당 객체의 식별자를 알고있다는 것. 링크를 통해서만 메시지를 주고받을 수 있다.

- 캡슐화(Encapsulation)
  - 메시지를 보내는 쪽에서는 상대 객체의 상태가 변경될지, 어떻게 변경되는지 알지 못한다.
  - 객체가 외부에 노출하는 것은 오로지 **행동**뿐! (단, 행동하는 구체적인 방법은 외부 객체가 알 수 없음)
  - 그런 의미에서, 무분별한(불필요한) setter의 남발은 삼가야 할테고, getter도 꼭 필요한 상태인 경우가 아니라면 쓰지 않는 것이 캡슐화를 저해하지 않는 방향일까?
  - 저자가 계속해서 강조하고 있는 것: 
    - 객체가 다른 객체와 협력하는 유일한 방법은 요청(메시지)를 보내는 것이다.
    - 메시지는 객체로 하여금 어떤 행동을 하게 만든다.
    - 유발된 행동은 해당 객체의 상태를 변경되게끔 만든다.
    - 단, 상태를 변경할지, 어떤 식으로 변경할 것인지 등은 메시지를 받은 객체가 자율적으로 결정한다. 즉 상태는 외부로 노출시키지 않고, 행동을 경계로 캡슐화한다.

- 객체는 식별자(identity)를 갖는다.
  - '동등성(equality)': **상태**가 같으면 두 값은 같음. 값은 불변(immutable) 상태를 가지며, 값 객체(value object)라고 함.
    - Java를 기준으로 한다면 `equals()`, `hashcode()`.
  - '동일성(identical)': (어떤 상태에 있더라도) **식별자**가 같으면 두 객체가 같음. 객체는 가변(mutable) 상태를 가지며, 참조 객체(reference object) 혹은 엔티티(entity)라고 함.

- Meyer의 '기계로서의 객체' 설명은 별 것 아닌 것 같지만 객체 간의 협력, 링크, 캡슐화 등의 개념을 이해하는 데 확실히 도움이 되는 것 같다.
  - Meyer가 제시한 관련 개념은 "*Command–Query Separation (CQS)*"라고 한다.

- 애플리케이션의 협력에 참여하는 객체들을 잘 설계하려면? '**행동**'에 초점을 맞추자. 객체가 적합한지를 결정하는 것은 ~~상태~~가 아니라 **행동**이다.
  - 애플리케이션에 필요한 '협력' 생각하기 -> 협력에 참여하는 데 필요한 '행동' 생각하기 -> 행동(들)을 수행할 '객체' 선택하기 -> 행동에 필요한 상태를 결정
  - **책임-주도 설계(Responsibility-Driven Design)**. "어떤 책임이 필요한가"를 결정하는 과정이 전체 설계를 주도해야 한다.

- '의인화'와 '은유'
  - 소프트웨어는 곧 생물이다. 현실 세계에서는 인간의 힘 없이는 아무 것도 못하는 객체라도, 객체지향 세계에서는 능동적이고 자율적인 존재가 된다.
  - 프로그램 내의 객체는 현실 속의 객체에 대한 은유다. 잘만 활용한다면 객체에 대한 표현적 차이를 줄여 의사소통에 도움을 주고, 유지보수도 쉬워진다.