# 2장 이상한 나라의 객체

1. 객체지향에서 프로퍼티와 필드 키워드의 차이점

    - https://medium.com/omarelgabrys-blog/properties-vs-fields-in-c-6cec86c59dc9
    

2. 앨리스 세상을 코드로 같이 짜보는것도 재밌을거 같아욧! (Ex 앨리스와 문크기가 랜덤으로 주어지고 플레이어가 버섯과 음료를 적절히 먹어서 문을 통과시키는 앨리스게임!)

3. 여담입니다만 status와 state의 차이점 (회사에선 대부분 status라는 키워드만 쓰던데)
 
  - https://blog.naver.com/tommy6753/220830550597?proxyReferer=https%3A%2F%2Fwww.google.com%2F

4. 상태캡슐화 (P55) 강사님의 미녀와야수 예제 기억나시나요? 피아노와 촛대가 스스로 움직이는 세상을 빗대어 말씀하셨는데 얼마나 좋은 예제였는지 무릎을 탁! 칩니다.
   
   - 강사님 강의 듣고싶다 힝구 ;ㅅ;

5. (P56 하단) 캡슐화를 잘하면 자율성이 높아지고 지능도 높아지고 협력은 유연하고 간결해진다. 즉 캡슐화가 오지게 중요하다는 말이네요.

6. P64 “안타깝게도 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다” = “채팀장님 : 기능을 먼저 생각하셔야죠! “

7. Q) p65 4번째 문단 “객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택하는 방식으로 수행된다” - 어떻게 협렵을 먼저 생각하지? 행동을 먼저 생각해야 역할이 나오고 역할들의 협력을 생각하는게 순서상 맞는거 아닐까요?
9
8. P66 “행동이 상태를 결정한다”

9. 객체지향 세계는 현실세계의 추상화가 아니라 은유화다

---

프로퍼티는 속성과 연관관계로 이루어져 있다는데 연관관계가 정적이라는 건 무슨 의미인가
    
    - 이런말이 어딨어 페이지 좀 적어주셈

객체에서 말하는 식별자는 구체적으로 뭘 말하는 건가? 프로퍼티라고 표현하는데 id 이런걸 말하는 건가?

    - 식별자는 참조가 가르키는 객체내부의 임의의 값이 아닐까 합니다. (해쉬코드는 아니다. 해쉬코드는 유일하지 않다.) 
    1) p58 4번째 문단 마지막 : 이처럼 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성 이라고 한다.
    2) 객체만 식별자를 가지고 값은 식별자를 가지지 않는다.

행동이 상태를 결정 짓는다라고 하는데 행동은 상태에 의존한다고도 하네?
 
    - 행동은 상태에 의존한다는 말이 어디있지?
    - p45 첫번쨰 문단 "행동의 **결과**를 결정하는 것은 상태다"을 말하는 것이라면, 예를들어 엘리스의 키가 100cm였는데 케이크를 먹는 행동이 50cm 만큼 앨리스의 키를 늘린다면 행동의 결과는 150cm가 된다. 즉 100cm 였던 상태가 행동의 **결과**를 결정했다. 

---

56p 캡슐화에 관한 설명이 너무 좋다

객체 상태를 변경할 지 여부는 객체 스스로가 판단한다

    - 짱슐화

---

- 캡슐화(Encapsulation)
  - 메시지를 보내는 쪽에서는 상대 객체의 상태가 변경될지, 어떻게 변경되는지 알지 못한다.
  - 객체가 외부에 노출하는 것은 오로지 **행동**뿐! (단, 행동하는 구체적인 방법은 외부 객체가 알 수 없음)
  - 그런 의미에서, 무분별한(불필요한) setter의 남발은 삼가야 할테고, getter도 꼭 필요한 상태인 경우가 아니라면 쓰지 않는 것이 캡슐화를 저해하지 않는 방향일까?
    
        - 맞습니다. 클라이언트가 정말 원하는 것이 "GET"인지 생각해봐야 합니다. 만약 Get 해온 데이터를 자신이 다시 가공하고 있다면 캡슐화를 저해되고 있다고 생각됨
        예를들어서, 영문이름을 저장하고 있는 DTO 객체의 값을 get 해와서, 해당 영문이름을 알파벳을 대문자로 바꾸는 행위를 클라이언트가 직접하고 있다면 이건 캡슐화가 안되었다고 생각됨.
        영문이름으로 바꿔서 반환하는 메소드가 캡슐화 되어 있어서 존재해야 된다고 생각.
        
  - 저자가 계속해서 강조하고 있는 것: 
    - 객체가 다른 객체와 협력하는 유일한 방법은 요청(메시지)를 보내는 것이다.
    - 메시지는 객체로 하여금 어떤 행동을 하게 만든다.
    - 유발된 행동은 해당 객체의 상태를 변경되게끔 만든다.
    - 단, 상태를 변경할지, 어떤 식으로 변경할 것인지 등은 메시지를 받은 객체가 자율적으로 결정한다. 즉 상태는 외부로 노출시키지 않고, 행동을 경계로 캡슐화한다.
    
    - 짱슐화

- 객체는 식별자(identity)를 갖는다.
  - '동등성(equality)': **상태**가 같으면 두 값은 같음. 값은 불변(immutable) 상태를 가지며, 값 객체(value object)라고 함.
    - Java를 기준으로 한다면 `equals()`, `hashcode()`.
  - '동일성(identical)': (어떤 상태에 있더라도) **식별자**가 같으면 두 객체가 같음. 객체는 가변(mutable) 상태를 가지며, 참조 객체(reference object) 혹은 엔티티(entity)라고 함.

- Meyer의 '기계로서의 객체' 설명은 별 것 아닌 것 같지만 객체 간의 협력, 링크, 캡슐화 등의 개념을 이해하는 데 확실히 도움이 되는 것 같다.
  - Meyer가 제시한 관련 개념은 "*Command–Query Separation (CQS)*"라고 한다.

- 애플리케이션의 협력에 참여하는 객체들을 잘 설계하려면? '**행동**'에 초점을 맞추자. 객체가 적합한지를 결정하는 것은 ~~상태~~가 아니라 **행동**이다.
  - 애플리케이션에 필요한 '협력' 생각하기 -> 협력에 참여하는 데 필요한 '행동' 생각하기 -> 행동(들)을 수행할 '객체' 선택하기 -> 행동에 필요한 상태를 결정
  - **책임-주도 설계(Responsibility-Driven Design)**. "어떤 책임이 필요한가"를 결정하는 과정이 전체 설계를 주도해야 한다.

- '의인화'와 '은유'
  - 소프트웨어는 곧 생물이다. 현실 세계에서는 인간의 힘 없이는 아무 것도 못하는 객체라도, 객체지향 세계에서는 능동적이고 자율적인 존재가 된다.
  - 프로그램 내의 객체는 현실 속의 객체에 대한 은유다. 잘만 활용한다면 객체에 대한 표현적 차이를 줄여 의사소통에 도움을 주고, 유지보수도 쉬워진다.