# 객체지향의 사실과 오해

## **06** 객체 지도

> 자주 변경되는 ~~기능~~이 아니라, 안정적인 **구조**를 따라 역할, 책임, 협력을 구성하라.

- 길을 모르는 상황에서 목적지를 향해 가는 방법 2가지
  - 🤷🏻‍♀️사람들한테 물어본다: **기능적**이고 해결 방법 지향적
  - 🗺지도를 본다: **구조적**이고 문제 지향적
  - 길을 찾는 데 필요한 '기능'은 현재의 요구만을 만족시킬 수 있다. 즉 변하기 쉽다.  
  하지만 '구조'는 범용적이고, 안정적이다. 즉 상대적으로 잘 변하지 않는다.
  - (이 부분에서 DIP가 생각났다. 구체적인 것에는 의존하지 말고 잘 변하지 않는 것, 즉 안정적인 것에 의존하라.)
- '구조'를 기반으로 모델을 구축하는 것이 더 범용적이고 이해하기 쉽고 변경에 안정적이다.

- <안정적인 구조>에 <변경이 빈번하게 발생하는 기능>을 종속시키는 것. 그것이 객체지향 개발 방법이다.

---
### 기능 설계 vs 구조 설계
- 소프트웨어가 가치 있는 이유는 사람들에게 유용한 '기능'을 제공하기 때문이다.
- 사용자들의 요구사항이 바뀌지 않을 것이 확실하다면, 훌륭한 '기능'을 제공하는 것이 소프트웨어 개발의 전부이고 훌륭한 '설계'는 그다지 중요하지 않을 수 있다.  
하지만 "*유일하게 변하지 않는 것은 모든 것이 변한다는 사실 뿐*"이라고 했던가. 훌륭한 설계, 다시 말해 깔끔하고 단순하며 유지보수하기 쉬운 설계는 쉽게 확장 가능한 소프트웨어를 창조할 수 있는 기반이 되고, 사용자의 변하는 요구사항을 반영할 수 있게 되는 것이다.  
한마디로, **설계가 중요한 이유는 요구사항은 항상 변경되기 때문이다**.
- 훌륭한 기능이 소프트웨어 개발의 충분조건이라면, 훌륭한 설계는 필요조건이다.
- 좋은 설계란, 미래의 변경을 예측하는 게 아니라 나중에라도 변경할 수 있는 선택의 여지를 남겨 놓는 설계다.
- 설계를 하는 목적은 나중에 설계하는 것을 허용하는 것이며, 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것이다.

- 객체지향 접근방법은 자주 변경되지 않는 **안정적인 객체 구조**를 바탕으로, 시스템 전체의 기능을 더 작은 책임으로 분배하고, 책임은 적절한 객체에게 분배된다. 즉 객체의 구조에 집중하고, 기능이 객체의 구조를 따르게 만든다.

---
### 안정적인 재료: 구조⠀⠀/⠀⠀도메인 모델
- **도메인**: 사용자가 프로그램을 사용하는 특정 대상 분야. (ex. 은행, 게임 등)
- **도메인 모델**: 소프트웨어 개발과 관련된 이해관계자들이 '도메인'에 대해 생각하는 관점. 여기서의 '모델'이란, 대상을 단순화해서 표현한 것으로, 도메인 모델이라고 하면 도메인과 관련된 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.

- Donald Norman의 '멘탈 모델'
  ![image](https://user-images.githubusercontent.com/26949964/70146151-fe1eb000-16e4-11ea-8c45-f94e76a8ecb9.png)
  - 사용자와 설계자는 직접적으로 상호작용할 수 없으며, 최종 제품인 '시스템' 그 자체를 통해서만 의사소통할 수 있다.
  - 따라서 설계자는 (디자이너 or 설계자의)디자인 모델을 기반으로 만든 시스템 이미지가 사용자 모델을 정확하게 반영하도록 노력해야 한다.
  - **도메인 모델은 소프트웨어에 대한 멘탈 모델이다.**

- 위의 멘탈 모델 그림을 도메인 모델이라고 생각해보면, 결국 최종 코드는 **사용자가 도메인을 바라보는 관점**을 반영해야 한다. 달리 말하면, 애플리케이션은 **도메인 모델을 기반으로 설계**돼야 한다.
- 도메인 모델의 3가지 측면을 모두 모델링할 수 있는 (거의 유일한) 패러다임이 바로 **객체지향**이다. 객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만들 수 있다.
  - 연결 완전성 or 표현적 차이(소프트웨어 객체와 현실 객체 사이의 의미적 거리)
- '현실 객체'와 (은유를 기반으로 재창조한)'소프트웨어 객체' 사이의 차이(= 표현적 차이)를 최대한 줄여야 한다.
  - 이를 위해 우리가 은유해야 하는 대상은 **도메인 모델**이며, **소프트웨어 객체는** 도메인 모델을 통해 표현되는 **도메인 객체들을 은유해야 한다**.
  - 도메인 모델을 기반으로 설계하고 구현하는 것은, 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있게 한다.
- 소프트웨어 개발의 최대 적은 변경이다. 따라서 변경될 확률이 적은 구조를 기반으로 설계와 구현을 하면, 향후 변경에 쉽게 대처할 수 있게 된다.
  - 도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해서 소프트웨어를 설계하고 구현하는 것인데, 사용자들은 누구보다도 도메인의 '본질적인' 측면을 가장 잘 이해하고 있다.
  - 따라서 사용자 모델을 기반으로 설계와 코드를 만들면, 변경에 쉽게 대처할 수 있을 가능성이 커진다.
  - 안정적인 구조를 기반으로 / 자주 변경되는 기능을 배치 => 기능의 변경에 대해 안정적인 소프트웨어
  - **도메인 모델은 코드 안에 존재하는 미로를 풀어갈 지도를 제공**한다. **기능을 구현할 때 참조할 수 있는 궁극적인 지도**다.

---
### 불안정한 재료: 기능
- 유스케이스(Use Case): (사용자의 목표를 달성하기 위해) 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것.
  - 단지 feature의 나열이 아니라, '사용자 목표'라는 문맥을 제공함으로써 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 한다.
  - 유스케이스의 5가지 특성: 194~195p

- 유스케이스는 단지 사용자가 바라보는 시스템의 외부 관점만을 표현하는 것일 뿐, 시스템의 내부 구조나 실행 매커니즘에 관한 정보는 전혀 제공하지 않는다.
  - 따라서 객체의 구조나 책임에 대한 정보도 전혀 제공하지 않는다.

---
### 재료 합치기: 기능과 구조의 통합
- 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배  
=> **변경에 유연한 소프트웨어**

![image](https://user-images.githubusercontent.com/26949964/70376429-5dcac480-194c-11ea-800d-b33a6ddc2920.png)

1. 유스케이스로부터 시스템이 제공해야 할 기능을 파악한다. 시스템의 기능은 곧 시스템의 책임이 되며, 시스템은 해당 메시지를 받는 거대한 객체라고 가정한다.
2. 시스템의 책임을 작은 규모의 객체들이 수행할 책임으로 분배한다. 이 때 안정적인 도메인 모델을 기반으로, 메시지를 받을 객체를 선택하고, 그 객체가 다른 객체에 전송할 메시지를 식별함으로써 자율적인 객체들의 협력 관계를 창조한다. (책임-주도 설계)
3. (객체와 책임이 식별됐으므로) 객체를 클래스로, 책임을 클래스의 메서드로 변환함으로써 구현한다.  
(간단하게, 도메인 모델의 속성을 클래스의 인스턴스 변수로, 협력 안에서의 책임을 메서드로 변환할 수 있다.)