# 객체지향의 사실과 오해

## **07** 함께 모으기

### 커피 전문점 도메인
1. 커피 전문점을 구성하는 **객체들을 식별**
2. 각 객체들을 **'타입'으로 분류**
3. 타입들 간의 **관계를 식별**
4. 타입과 관계를 이용해 객체들을 추상화 → '**도메인 모델**'
* 도메인 모델: 소프트웨어가 대상으로 하는 영역인 '도메인'을 단순화해서 표현한 모델

![image](https://user-images.githubusercontent.com/26949964/70444475-45d67a80-1add-11ea-8a39-f57244ad82e9.png)  

---
- 객체지향 설계의 첫번째 목표는? 훌륭한 협력을 설계하는 것.
- 메시지가 객체를 선택한다. (메시지가 인터페이스를 결정한다)
  - 메시지를 먼저 선택 → 메시지를 수신하기에 적절한 객체를 선택
  - 객체는 메시지를 처리할 책임을 가짐, 객체가 수신하는 메시지는 공용 인터페이스에 포함된다.

---
- 유스케이스로부터 '커피를 주문하라'라는 메시지를 가져옴.
- 이 메시지를 처리하기에 적합한 객체를 선택해야 하는데, 위에서 정한 도메인 모델을 기반으로 한다.
  - 도메인 모델을 살펴보니, '커피를 주문하라'라는 책임을 수행하기에 적절한 타입은 손님. → 손님 인스턴스 생성
  - 손님이 커피를 주문하는 도중에, 메뉴 항목을 스스로 찾을 수 없으므로, 메뉴판에게 '메뉴 항목을 찾아라'라는 메시지를 전송
  - ... 위와 같이 진행하면서, 협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 윤곽을 잡는다.
  ![image](https://user-images.githubusercontent.com/26949964/70445395-cd70b900-1ade-11ea-89fd-acde97d1b96d.png)

---
### 인터페이스 정리하기

- 수신한 메시지가 객체의 인터페이스를 결정한다.
  - 즉, 메시지가 객체를 선택 → 선택된 객체가 메시지를 자신의 인터페이스로 받아들인다(인터페이스에 포함시킨다).
  - 객체들을 포괄하는 타입을 정의 → 식별된 오퍼레이션을 타입의 인터페이스에 추가
  ![image](https://user-images.githubusercontent.com/26949964/70445673-39532180-1adf-11ea-91aa-2069f361e40d.png)

---
### 구현하기
- 클래스의 인터페이스를 식별 → 오퍼레이션을 수행하는 구체적인 방법을 메서드로 구현한다.
- *(실제 구현코드는 생략)*

---
### 코드의 세가지 관점
- **개념 관점**
  - 클래스가 도메인 모델을 제대로 반영하고 있는가
  - 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하고 둘 사이의 간격이 좁을수록, 변경을 관리하기 쉽고 유지보수성이 향상된다.
- **명세 관점**
  - 클래스의 인터페이스(public 메서드의 signature)를 바라보는 관점
  - 객체의 (공용)인터페이스가 수정되면, 해당 객체와 협력하는 객체가 직접적인 영향을 받게 된다. 즉 인터페이스는 수정하기 어려운 대상이다.
  - 변화에 안정적인 인터페이스를 만드려면, 인터페이스와 구현을 분리하라!
- **구현 관점**
  - 클래스의 내부 구현을 바라보는 관점
  - 속성 & 메서드의 body
  - 메서드와 속성이 클래스 내부로 철저하게 캡슐화되어야 한다. 즉 메서드의 구현과 속성은 외부의 객체에게 영향을 미쳐선 안된다.
  - = 클래스의 내부 구현이 변경되어도 → 공용 인터페이스에 영향 X → 협력 대상인 객체에게 영향 X

위의 세 가지 관점을 모두 포함하면서, 각 관점에 대응되는 요소가 명확하고 깔끔하게 드러나도록 하자.

- 어떤 메시지가 있을 때, 그 메시지를 수신할 객체를 어떻게 선택하는가?
  - 도메인 개념 중에서 가장 적절한 것을 선택
  - 도메인에 대한 지식을 기반으로 코드를 쉽게 인식할 수 있으므로 유지보수성에 도움
- 인터페이스와 구현을 분리
  - 명세 관점: 클래스의 **안정**적인 측면 (WHAT)
  - 구현 관점: 클래스의 **불안정**한 측면 (HOW)
  - 명세 관점과 구현 관점을 분리하는 것은 매우 중요하다.
  - 명세 관점(=인터페이스 =메시지)이 설계를 주도하게 하라.
  - **클래스를 딱 봤을 때, 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다.**
