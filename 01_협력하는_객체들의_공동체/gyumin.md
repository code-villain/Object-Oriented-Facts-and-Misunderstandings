# 객체지향의 사실과 오해

## **01** 협력하는 객체들의 공동체

- 객체지향 애플리케이션이 실세계를 모방해야 한다는 아이디어는 유연하지 못하고, 실용적이지 않다... 소프트웨어 객체와 실세계 사물 사이에 존재하는 연관성은 희미하다.

- 객체가 자신의 책임을 수행하는 방법은 자율적으로 선택할 수 있다. (28p)
  - 책임을 수행하는 '방법'이란 곧 메서드이다(객체는 메시지를 수신하고 메시지를 자신만의 방법에 따라 처리하는데, 그 방법이 곧 메서드라고 언급하고 있다; 34p). 달리 말하면 책임과 메서드는 유사하긴 하지만 완전히 동일한 개념으로 볼 수는 없는데, **책임은 메서드에 비해 더 추상적인 개념**으로 이해하면 될 듯하다.  
  동일한 요청(=메시지)에 대해 서로 다른 방식으로 응답할 수 있는 능력(=다형성)에 대해 언급하고 있는데, 여기서의 '요청'과 요청을 받은 객체의 '책임'을 대응시켜서 이해할 수도 있겠다. 즉 어떤 책임을 수행하는 객체에게 다른 객체가 요청을 보내 책임을 수행하도록 하면, 메시지를 받은 해당 객체는 자율적인 방법으로 책임을 수행하는 것이며, 그 구체적인 방법이라는 것은 여러 개가 존재할 수도 있는 것이다.

- 하나의 객체가 동시에 여러 역할을 수행할 수 있다. (30p)
  - 역할이라는 것을 프로그래밍 언어의 `interface`에 대응해본다면, 여러 개의 interface를 구현하는 객체의 모습을 생각해보면 될 듯하다.
  - 캐셔와 바리스타라는 개별적인 역할들의 협력관계도 가능하지만, 한 사람이 캐셔와 바리스타의 역할을 동시에 수행하는 것도 가능하다는 것이다.
  - 이 부분을 보고, "하나의 객체가 여러 역할을 동시에 수행하면 SRP 위반 아닌가? 하나의 객체는 하나의 책임만 가져야 하잖아? 다중구현(하나의 클래스가 여러 interface를 구현)도 SRP 위반인가?"라는 생각이 들었다. 이와 관련하여 **«클린 아키텍처»의 7장 SRP** 내용이 해답을 주었다.  
  클린아키텍쳐에서 재정의한 SRP란, *하나의 모듈은 하나의 액터에 대해서만 책임져야 한다*는 것이다. 여기서의 모듈은 소스코드로 볼 수 있고, 액터란 해당 객체를 사용하는, 즉 객체에 변경을 일으키는 한 명 이상의 사람들(집단)을 뜻한다.
  정리하면, **SRP를 준수하는지 판단하는 기준**은 단순히 객체가 '하나의 일만 해야한다', '하나의 책임만을 가진다'라고 할 수는 없고, 해당 객체를 사용하는 쪽, 즉 액터에 달려있는 것이다.
  - 이 기준을 가지고 "하나의 객체가 동시에 여러 역할을 수행"하는 것이 SRP를 위반하는 것인지를 생각해본다면, 무조건 그런 것은 아니라는 결론이 나온다. **객체가 동시에 여러 역할을 수행한다 하더라도, 해당 객체에 의존하고 있는 액터가 하나만 있다면 SRP 위반이 아니다**.

- 애플리케이션의 기능은 더 작은 책임으로 분할되고, 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다. … 적절한 객체에게 적절한 책임을 할당해야 한다. ... 결론적으로 시스템은 역할과 책임을 수행하는 객체로 분할되고, 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현된다. (30p)
  > "애플리케이션에 어떤 기능들이 필요할지 먼저 생각하고, 그 중에서 유사한 기능들을 모아 하나의 객체를 규정하는 순서로 애플리케이션을 설계해야 한다" (I사 최 팀장님 曰)

- 역할은 협력에 참여하는 객체에 대한 일종의 '페르소나'다. (30p)
  - 어떤 의미로 '페르소나'라고 한 것인지 알쏭달쏭하다. 프로그래밍 언어의 `interface`를 뜻하는 것일까?

- 전지전능하신 god object(하나님 객체)는 아니된다. (31p)
  - 각자 역할과 책임을 갖는 다양한 객체들 간의 협력을 통해 애플리케이션의 목표가 달성된다. «UML for Java Programmers»에서도 나온 이야기! 하나님 객체는 내부적인 복잡도에 의해 자멸하고 만다.

- 객체는 충분히 '자율적'이어야 한다... 다른 객체가 ‘무엇(what)’을 수행하는지는 알 수 있지만 ‘어떻게(how)’ 수행하는지에 대해서는 알 수 없다. (32-33p)
  - "Tell, Don’t Ask" 원칙과 일맥상통하는 내용으로 이해했다.
  - 송신자(sender)는 요청, 즉 메시지만 보내고 그 메시지를 받는 수신자(receiver)가 자신만의 방법(=메서드)으로 메시지를 처리한다. 송신자는 수신자의 구체적인 처리 방법에 대해서 관여하지 않는다. 이렇게 **메시지와 메서드를 분리**하는 것은 **객체의 자율성**을 높이는 핵심 매커니즘이다. (≓ 캡슐화)

- 객체지향의 중심은 ~~클래스~~가 아니라 **객체**다. 중요한 것은 ~~클래스들의 정적인 관계~~가 아니라 **메시지를 주고받는 객체들의 동적인 관계**다. ... ~~클래스의 구조와 메서드~~가 아니라 **객체의 역할, 책임, 협력**에 집중하라. (38p)
  - 클래스를 만들 생각부터 하고, 그 다음에 해당 클래스의 메서드를 만들기 시작하는 순서가 아니라!  
  애플리케이션의 목표를 달성하기 위해서 어떤 기능들이 필요한가, 그리고 그 기능들을 각각 어떤 객체에서 수행해야 할까? 라는 고민을 하도록 하자. 클래스는 객체를 만드는 데 필요한 수단일 뿐이다.